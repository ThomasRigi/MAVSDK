// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/master/protos/telemetry/telemetry.proto)

#pragma once

#include <array>
#include <functional>
#include <limits>
#include <memory>
#include <string>
#include <vector>

#include "plugin_base.h"

namespace mavsdk {

class System;
class TelemetryImpl;

/**
 * @brief Allow users to get vehicle telemetry and state information
 * (e.g. battery, GPS, RC connection, flight mode etc.) and set telemetry update rates.
 */
class Telemetry : public PluginBase {
public:
    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto telemetry = std::make_shared<Telemetry>(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit Telemetry(System& system);

    /**
     * @brief Destructor (internal use only).
     */
    ~Telemetry();

    /**
     * @brief GPS fix type.
     */
    enum class FixType {
        NoGps, /**< @brief No GPS connected. */
        NoFix, /**< @brief No position information, GPS is connected. */
        Fix2D, /**< @brief 2D position. */
        Fix3D, /**< @brief 3D position. */
        FixDgps, /**< @brief DGPS/SBAS aided 3D position. */
        RtkFloat, /**< @brief RTK float, 3D position. */
        RtkFixed, /**< @brief RTK Fixed, 3D position. */
    };

    /**
     * @brief Flight modes.
     *
     * For more information about flight modes, check out
     * https://docs.px4.io/en/config/flight_mode.html.
     */
    enum class FlightMode {
        Unknown, /**< @brief Mode not known. */
        Ready, /**< @brief Armed and ready to take off. */
        Takeoff, /**< @brief Taking off. */
        Hold, /**< @brief Holding (hovering in place (or circling for fixed-wing vehicles). */
        Mission, /**< @brief In mission. */
        ReturnToLaunch, /**< @brief Returning to launch position (then landing). */
        Land, /**< @brief Landing. */
        Offboard, /**< @brief In 'offboard' mode. */
        FollowMe, /**< @brief In 'follow-me' mode. */
        Manual, /**< @brief In 'Manual' mode. */
        Altctl, /**< @brief In 'Altitude Control' mode. */
        Posctl, /**< @brief In 'Position Control' mode. */
        Acro, /**< @brief In 'Acro' mode. */
        Stabilized, /**< @brief In 'Stabilize' mode. */
        Rattitude, /**< @brief In 'Rattitude' mode. */
    };

    /**
     * @brief Landed State enumeration.
     */
    enum class LandedState {
        LandedStateUnknown, /**< @brief Landed state is unknown. */
        LandedStateOnGround, /**< @brief The vehicle is on the ground. */
        LandedStateInAir, /**< @brief The vehicle is in the air. */
        LandedStateTakingOff, /**< @brief The vehicle is taking off. */
        LandedStateLanding, /**< @brief The vehicle is landing. */
    };




    /**
     * @brief Position type in global coordinates.
     */
    struct Position {
        double latitude_deg; /**< @brief Latitude in degrees (range: -90 to +90) */
        double longitude_deg; /**< @brief Longitude in degrees (range: -180 to +180) */
        float absolute_altitude_m; /**< @brief Altitude AMSL (above mean sea level) in metres */
        float relative_altitude_m; /**< @brief Altitude relative to takeoff altitude in metres */
        
    };





    /**
     * @brief Quaternion type.
     *
     * All rotations and axis systems follow the right-hand rule.
     * The Hamilton quaternion product definition is used.
     * A zero-rotation quaternion is represented by (1,0,0,0).
     * The quaternion could also be written as w + xi + yj + zk.
     *
     * For more info see: https://en.wikipedia.org/wiki/Quaternion
     */
    struct Quaternion {
        float w; /**< @brief Quaternion entry 0, also denoted as a */
        float x; /**< @brief Quaternion entry 1, also denoted as b */
        float y; /**< @brief Quaternion entry 2, also denoted as c */
        float z; /**< @brief Quaternion entry 3, also denoted as d */
        
    };





    /**
     * @brief Euler angle type.
     *
     * All rotations and axis systems follow the right-hand rule.
     * The Euler angles follow the convention of a 3-2-1 intrinsic Tait-Bryan rotation sequence.
     *
     * For more info see https://en.wikipedia.org/wiki/Euler_angles
     */
    struct EulerAngle {
        float roll_deg; /**< @brief Roll angle in degrees, positive is banking to the right */
        float pitch_deg; /**< @brief Pitch angle in degrees, positive is pitching nose up */
        float yaw_deg; /**< @brief Yaw angle in degrees, positive is clock-wise seen from above */
        
    };





    /**
     * @brief Angular velocity type.
     */
    struct AngularVelocityBody {
        float roll_rad_s; /**< @brief Roll angular velocity */
        float pitch_rad_s; /**< @brief Pitch angular velocity */
        float yaw_rad_s; /**< @brief Yaw angular velocity */
        
    };





    /**
     * @brief Speed type, represented in the NED (North East Down) frame and in metres/second.
     */
    struct SpeedNed {
        float velocity_north_m_s; /**< @brief Velocity in North direction in metres/second */
        float velocity_east_m_s; /**< @brief Velocity in East direction in metres/second */
        float velocity_down_m_s; /**< @brief Velocity in Down direction in metres/second */
        
    };





    /**
     * @brief GPS information type.
     */
    struct GpsInfo {
        int32_t num_satellites; /**< @brief Number of visible satellites in use */
        FixType fix_type; /**< @brief Fix type */
        
    };





    /**
     * @brief Battery type.
     */
    struct Battery {
        float voltage_v; /**< @brief Voltage in volts */
        float remaining_percent; /**< @brief Estimated battery remaining (range: 0.0 to 1.0) */
        
    };





    /**
     * @brief Health type.
     */
    struct Health {
        bool is_gyrometer_calibration_ok; /**< @brief True if the gyrometer is calibrated */
        bool is_accelerometer_calibration_ok; /**< @brief True if the accelerometer is calibrated */
        bool is_magnetometer_calibration_ok; /**< @brief True if the magnetometer is calibrated */
        bool is_level_calibration_ok; /**< @brief True if the vehicle has a valid level calibration */
        bool is_local_position_ok; /**< @brief True if the local position estimate is good enough to fly in 'position control' mode */
        bool is_global_position_ok; /**< @brief True if the global position estimate is good enough to fly in 'position control' mode */
        bool is_home_position_ok; /**< @brief True if the home position has been initialized properly */
        
    };





    /**
     * @brief Remote control status type.
     */
    struct RcStatus {
        bool was_available_once; /**< @brief True if an RC signal has been available once */
        bool is_available; /**< @brief True if the RC signal is available now */
        float signal_strength_percent; /**< @brief Signal strength (range: 0 to 100) */
        
    };




    /**
     * @brief Status types.
     */
    enum class StatusType {
        Info, /**< @brief Information or other. */
        Warning, /**< @brief Warning. */
        Critical, /**< @brief Critical. */
    };


    /**
     * @brief StatusText information type.
     */
    struct StatusText {
        StatusType type; /**< @brief Message type */
        std::string text; /**< @brief MAVLink status message */
        
    };





    /**
     * @brief Actuator control target type.
     */
    struct ActuatorControlTarget {
        int32_t group; /**< @brief TODO */
        std::vector<float> controls; /**< @brief TODO */
        
    };





    /**
     * @brief 
     */
    struct ActuatorOutputStatus {
        uint32_t active; /**< @brief TODO */
        std::vector<float> actuator; /**< @brief TODO */
        
    };





    /**
     * @brief Covariance type.
     *
     * Row-major representation of a 6x6 cross-covariance matrix
     * upper right triangle.
     * Set first to NaN if unknown.
     */
    struct Covariance {
        std::vector<float> covariance_matrix; /**< @brief Representation of a covariance matrix. */
        
    };





    /**
     * @brief Velocity type, represented in the Body (X Y Z) frame and in metres/second.
     */
    struct VelocityBody {
        float x_m_s; /**< @brief Velocity in X in metres/second */
        float y_m_s; /**< @brief Velocity in Y in metres/second */
        float z_m_s; /**< @brief Velocity in Z in metres/second */
        
    };





    /**
     * @brief Position type, represented in the Body (X Y Z) frame
     */
    struct PositionBody {
        float x_m; /**< @brief X Position in metres. */
        float y_m; /**< @brief Y Position in metres. */
        float z_m; /**< @brief Z Position in metres. */
        
    };




    /**
     * @brief Mavlink frame id
     */
    enum class MavFrame {
        Undef, /**< @brief Frame is undefined.. */
        BodyNed, /**< @brief Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right.. */
        VisionNed, /**< @brief Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: north, y: east, z: down).. */
        EstimNed, /**< @brief Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: north, y: east, z: down).. */
    };


    /**
     * @brief Odometry message type.
     */
    struct Odometry {
        uint64_t time_usec; /**< @brief Timestamp (0 to use Backend timestamp). */
        MavFrame frame_id; /**< @brief Coordinate frame of reference for the pose data. */
        MavFrame child_frame_id; /**< @brief Coordinate frame of reference for the velocity in free space (twist) data. */
        PositionBody position_body; /**< @brief Position. */
        Quaternion q; /**< @brief Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation). */
        VelocityBody velocity_body; /**< @brief Linear velocity (m/s). */
        AngularVelocityBody angular_velocity_body; /**< @brief Angular velocity (rad/s). */
        Covariance pose_covariance; /**< @brief Pose cross-covariance matrix. */
        Covariance velocity_covariance; /**< @brief Velocity cross-covariance matrix. */
        
    };





    /**
     * @brief PositionNed message type.
     */
    struct PositionNed {
        float north_m; /**< @brief Position along north direction in metres */
        float east_m; /**< @brief Position along east direction in metres */
        float down_m; /**< @brief Position along down direction in metres */
        
    };





    /**
     * @brief VelocityNed message type.
     */
    struct VelocityNed {
        float north_m_s; /**< @brief Velocity along north direction in metres per second */
        float east_m_s; /**< @brief Velocity along east direction in metres per second */
        float down_m_s; /**< @brief Velocity along down direction in metres per second */
        
    };





    /**
     * @brief PositionVelocityNed message type.
     */
    struct PositionVelocityNed {
        PositionNed position; /**< @brief Position (NED) */
        VelocityNed velocity; /**< @brief Velocity (NED) */
        
    };





    /**
     * @brief GroundTruth message type.
     */
    struct GroundTruth {
        double latitude_deg; /**< @brief Latitude in degrees (range: -90 to +90) */
        double longitude_deg; /**< @brief Longitude in degrees (range: -180 to 180) */
        float absolute_altitude_m; /**< @brief Altitude AMSL (above mean sea level) in metres */
        
    };





    /**
     * @brief FixedwingMetrics message type.
     */
    struct FixedwingMetrics {
        float airspeed_m_s; /**< @brief Current indicated airspeed (IAS) in metres per second */
        float throttle_percentage; /**< @brief Current throttle setting (0 to 100) */
        float climb_rate_m_s; /**< @brief Current climb rate in metres per second */
        
    };





    /**
     * @brief AccelerationFrd message type.
     */
    struct AccelerationFrd {
        float forward_m_s2; /**< @brief Acceleration in forward direction in metres per second^2 */
        float right_m_s2; /**< @brief Acceleration in right direction in metres per second^2 */
        float down_m_s2; /**< @brief Acceleration in down direction in metres per second^2 */
        
    };





    /**
     * @brief AngularVelocityFrd message type.
     */
    struct AngularVelocityFrd {
        float forward_rad_s; /**< @brief Angular velocity in forward direction in radians per second */
        float right_rad_s; /**< @brief Angular velocity in right direction in radians per second */
        float down_rad_s; /**< @brief Angular velocity in Down direction in radians per second */
        
    };





    /**
     * @brief MagneticFieldFrd message type.
     */
    struct MagneticFieldFrd {
        float forward_gauss; /**< @brief Magnetic field in forward direction measured in Gauss */
        float right_gauss; /**< @brief Magnetic field in East direction measured in Gauss */
        float down_gauss; /**< @brief Magnetic field in Down direction measured in Gauss */
        
    };





    /**
     * @brief Imu message type.
     */
    struct Imu {
        AccelerationFrd acceleration_frd; /**< @brief Acceleration */
        AngularVelocityFrd angular_velocity_frd; /**< @brief Angular velocity */
        MagneticFieldFrd magnetic_field_frd; /**< @brief Magnetic field */
        float temperature_degc; /**< @brief Temperature */
        
    };




    /**
     * @brief Possible results returned for telemetry requests.
     */
    enum class Result {
        Unknown, /**< @brief Unknown error. */
        Success, /**< @brief Success: the telemetry command was accepted by the vehicle. */
        NoSystem, /**< @brief No system connected. */
        ConnectionError, /**< @brief Connection error. */
        Busy, /**< @brief Vehicle is busy. */
        CommandDenied, /**< @brief Command refused by vehicle. */
        Timeout, /**< @brief Request timed out. */
    };





    /**
     * @brief Callback type for asynchronous Telemetry calls.
     */
    typedef std::function<void(Result)> result_callback_t;



    /**
    * @brief Callback type for position_async.
    */
    typedef std::function<void(Position)> position_callback_t;

    /**
     * @brief Subscribe to 'position' updates.
     */
    void position_async(position_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one Position update.
     *
     * @return One Position update.
     */
    Position position() const;


    /**
    * @brief Callback type for home_async.
    */
    typedef std::function<void(Position)> home_callback_t;

    /**
     * @brief Subscribe to 'home position' updates.
     */
    void home_async(home_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one Position update.
     *
     * @return One Position update.
     */
    Position home() const;


    /**
    * @brief Callback type for in_air_async.
    */
    typedef std::function<void(bool)> in_air_callback_t;

    /**
     * @brief Subscribe to in-air updates.
     */
    void in_air_async(in_air_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one bool update.
     *
     * @return One bool update.
     */
    bool in_air() const;


    /**
    * @brief Callback type for landed_state_async.
    */
    typedef std::function<void(LandedState)> landed_state_callback_t;

    /**
     * @brief Subscribe to landed state updates
     */
    void landed_state_async(landed_state_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one LandedState update.
     *
     * @return One LandedState update.
     */
    LandedState landed_state() const;


    /**
    * @brief Callback type for armed_async.
    */
    typedef std::function<void(bool)> armed_callback_t;

    /**
     * @brief Subscribe to armed updates.
     */
    void armed_async(armed_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one bool update.
     *
     * @return One bool update.
     */
    bool armed() const;


    /**
    * @brief Callback type for attitude_quaternion_async.
    */
    typedef std::function<void(Quaternion)> attitude_quaternion_callback_t;

    /**
     * @brief Subscribe to 'attitude' updates (quaternion).
     */
    void attitude_quaternion_async(attitude_quaternion_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one Quaternion update.
     *
     * @return One Quaternion update.
     */
    Quaternion attitude_quaternion() const;


    /**
    * @brief Callback type for attitude_euler_async.
    */
    typedef std::function<void(EulerAngle)> attitude_euler_callback_t;

    /**
     * @brief Subscribe to 'attitude' updates (Euler).
     */
    void attitude_euler_async(attitude_euler_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one EulerAngle update.
     *
     * @return One EulerAngle update.
     */
    EulerAngle attitude_euler() const;


    /**
    * @brief Callback type for attitude_angular_velocity_body_async.
    */
    typedef std::function<void(AngularVelocityBody)> attitude_angular_velocity_body_callback_t;

    /**
     * @brief Subscribe to 'attitude' updates (angular velocity)
     */
    void attitude_angular_velocity_body_async(attitude_angular_velocity_body_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one AngularVelocityBody update.
     *
     * @return One AngularVelocityBody update.
     */
    AngularVelocityBody attitude_angular_velocity_body() const;


    /**
    * @brief Callback type for camera_attitude_quaternion_async.
    */
    typedef std::function<void(Quaternion)> camera_attitude_quaternion_callback_t;

    /**
     * @brief Subscribe to 'camera attitude' updates (quaternion).
     */
    void camera_attitude_quaternion_async(camera_attitude_quaternion_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one Quaternion update.
     *
     * @return One Quaternion update.
     */
    Quaternion camera_attitude_quaternion() const;


    /**
    * @brief Callback type for camera_attitude_euler_async.
    */
    typedef std::function<void(EulerAngle)> camera_attitude_euler_callback_t;

    /**
     * @brief Subscribe to 'camera attitude' updates (Euler).
     */
    void camera_attitude_euler_async(camera_attitude_euler_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one EulerAngle update.
     *
     * @return One EulerAngle update.
     */
    EulerAngle camera_attitude_euler() const;


    /**
    * @brief Callback type for ground_speed_ned_async.
    */
    typedef std::function<void(SpeedNed)> ground_speed_ned_callback_t;

    /**
     * @brief Subscribe to 'ground speed' updates (NED).
     */
    void ground_speed_ned_async(ground_speed_ned_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one SpeedNed update.
     *
     * @return One SpeedNed update.
     */
    SpeedNed ground_speed_ned() const;


    /**
    * @brief Callback type for gps_info_async.
    */
    typedef std::function<void(GpsInfo)> gps_info_callback_t;

    /**
     * @brief Subscribe to 'GPS info' updates.
     */
    void gps_info_async(gps_info_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one GpsInfo update.
     *
     * @return One GpsInfo update.
     */
    GpsInfo gps_info() const;


    /**
    * @brief Callback type for battery_async.
    */
    typedef std::function<void(Battery)> battery_callback_t;

    /**
     * @brief Subscribe to 'battery' updates.
     */
    void battery_async(battery_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one Battery update.
     *
     * @return One Battery update.
     */
    Battery battery() const;


    /**
    * @brief Callback type for flight_mode_async.
    */
    typedef std::function<void(FlightMode)> flight_mode_callback_t;

    /**
     * @brief Subscribe to 'flight mode' updates.
     */
    void flight_mode_async(flight_mode_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one FlightMode update.
     *
     * @return One FlightMode update.
     */
    FlightMode flight_mode() const;


    /**
    * @brief Callback type for health_async.
    */
    typedef std::function<void(Health)> health_callback_t;

    /**
     * @brief Subscribe to 'health' updates.
     */
    void health_async(health_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one Health update.
     *
     * @return One Health update.
     */
    Health health() const;


    /**
    * @brief Callback type for rc_status_async.
    */
    typedef std::function<void(RcStatus)> rc_status_callback_t;

    /**
     * @brief Subscribe to 'RC status' updates.
     */
    void rc_status_async(rc_status_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one RcStatus update.
     *
     * @return One RcStatus update.
     */
    RcStatus rc_status() const;


    /**
    * @brief Callback type for status_text_async.
    */
    typedef std::function<void(StatusText)> status_text_callback_t;

    /**
     * @brief Subscribe to 'status text' updates.
     */
    void status_text_async(status_text_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one StatusText update.
     *
     * @return One StatusText update.
     */
    StatusText status_text() const;


    /**
    * @brief Callback type for actuator_control_target_async.
    */
    typedef std::function<void(ActuatorControlTarget)> actuator_control_target_callback_t;

    /**
     * @brief Subscribe to 'actuator control target' updates.
     */
    void actuator_control_target_async(actuator_control_target_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one ActuatorControlTarget update.
     *
     * @return One ActuatorControlTarget update.
     */
    ActuatorControlTarget actuator_control_target() const;


    /**
    * @brief Callback type for actuator_output_status_async.
    */
    typedef std::function<void(ActuatorOutputStatus)> actuator_output_status_callback_t;

    /**
     * @brief Subscribe to 'actuator output status' updates.
     */
    void actuator_output_status_async(actuator_output_status_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one ActuatorOutputStatus update.
     *
     * @return One ActuatorOutputStatus update.
     */
    ActuatorOutputStatus actuator_output_status() const;


    /**
    * @brief Callback type for odometry_async.
    */
    typedef std::function<void(Odometry)> odometry_callback_t;

    /**
     * @brief Subscribe to 'odometry' updates.
     */
    void odometry_async(odometry_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one Odometry update.
     *
     * @return One Odometry update.
     */
    Odometry odometry() const;


    /**
    * @brief Callback type for position_velocity_ned_async.
    */
    typedef std::function<void(PositionVelocityNed)> position_velocity_ned_callback_t;

    /**
     * @brief Subscribe to 'position velocity' updates.
     */
    void position_velocity_ned_async(position_velocity_ned_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one PositionVelocityNed update.
     *
     * @return One PositionVelocityNed update.
     */
    PositionVelocityNed position_velocity_ned() const;


    /**
    * @brief Callback type for ground_truth_async.
    */
    typedef std::function<void(GroundTruth)> ground_truth_callback_t;

    /**
     * @brief Subscribe to 'ground truth' updates.
     */
    void ground_truth_async(ground_truth_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one GroundTruth update.
     *
     * @return One GroundTruth update.
     */
    GroundTruth ground_truth() const;


    /**
    * @brief Callback type for fixedwing_metrics_async.
    */
    typedef std::function<void(FixedwingMetrics)> fixedwing_metrics_callback_t;

    /**
     * @brief Subscribe to 'fixedwing metrics' updates.
     */
    void fixedwing_metrics_async(fixedwing_metrics_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one FixedwingMetrics update.
     *
     * @return One FixedwingMetrics update.
     */
    FixedwingMetrics fixedwing_metrics() const;


    /**
    * @brief Callback type for imu_async.
    */
    typedef std::function<void(Imu)> imu_callback_t;

    /**
     * @brief Subscribe to 'IMU' updates.
     */
    void imu_async(imu_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one Imu update.
     *
     * @return One Imu update.
     */
    Imu imu() const;


    /**
    * @brief Callback type for health_all_ok_async.
    */
    typedef std::function<void(bool)> health_all_ok_callback_t;

    /**
     * @brief Subscribe to 'HealthAllOk' updates.
     */
    void health_all_ok_async(health_all_ok_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one bool update.
     *
     * @return One bool update.
     */
    bool health_all_ok() const;


    /**
    * @brief Callback type for unix_epoch_time_async.
    */
    typedef std::function<void(uint64_t)> unix_epoch_time_callback_t;

    /**
     * @brief Subscribe to 'unix epoch time' updates.
     */
    void unix_epoch_time_async(unix_epoch_time_callback_t callback);

    /**
     * @brief Synchronous wrapper getting one uint64_t update.
     *
     * @return One uint64_t update.
     */
    uint64_t unix_epoch_time() const;


    /**
     * @brief Set rate to 'position' updates.
     */
    void set_rate_position_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_position_async().
     *
     * @return Result of request.
     */
    Result set_rate_position(double rate_hz) const;


    /**
     * @brief Set rate to 'home position' updates.
     */
    void set_rate_home_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_home_async().
     *
     * @return Result of request.
     */
    Result set_rate_home(double rate_hz) const;


    /**
     * @brief Set rate to in-air updates.
     */
    void set_rate_in_air_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_in_air_async().
     *
     * @return Result of request.
     */
    Result set_rate_in_air(double rate_hz) const;


    /**
     * @brief Set rate to landed state updates
     */
    void set_rate_landed_state_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_landed_state_async().
     *
     * @return Result of request.
     */
    Result set_rate_landed_state(double rate_hz) const;


    /**
     * @brief Set rate to 'attitude' updates.
     */
    void set_rate_attitude_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_attitude_async().
     *
     * @return Result of request.
     */
    Result set_rate_attitude(double rate_hz) const;


    /**
     * @brief Set rate of camera attitude updates.
     */
    void set_rate_camera_attitude_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_camera_attitude_async().
     *
     * @return Result of request.
     */
    Result set_rate_camera_attitude(double rate_hz) const;


    /**
     * @brief Set rate to 'ground speed' updates (NED).
     */
    void set_rate_ground_speed_ned_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_ground_speed_ned_async().
     *
     * @return Result of request.
     */
    Result set_rate_ground_speed_ned(double rate_hz) const;


    /**
     * @brief Set rate to 'GPS info' updates.
     */
    void set_rate_gps_info_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_gps_info_async().
     *
     * @return Result of request.
     */
    Result set_rate_gps_info(double rate_hz) const;


    /**
     * @brief Set rate to 'battery' updates.
     */
    void set_rate_battery_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_battery_async().
     *
     * @return Result of request.
     */
    Result set_rate_battery(double rate_hz) const;


    /**
     * @brief Set rate to 'RC status' updates.
     */
    void set_rate_rc_status_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_rc_status_async().
     *
     * @return Result of request.
     */
    Result set_rate_rc_status(double rate_hz) const;


    /**
     * @brief Set rate to 'actuator control target' updates.
     */
    void set_rate_actuator_control_target_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_actuator_control_target_async().
     *
     * @return Result of request.
     */
    Result set_rate_actuator_control_target(double rate_hz) const;


    /**
     * @brief Set rate to 'actuator output status' updates.
     */
    void set_rate_actuator_output_status_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_actuator_output_status_async().
     *
     * @return Result of request.
     */
    Result set_rate_actuator_output_status(double rate_hz) const;


    /**
     * @brief Set rate to 'odometry' updates.
     */
    void set_rate_odometry_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_odometry_async().
     *
     * @return Result of request.
     */
    Result set_rate_odometry(double rate_hz) const;


    /**
     * @brief Set rate to 'position velocity' updates.
     */
    void set_rate_position_velocity_ned_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_position_velocity_ned_async().
     *
     * @return Result of request.
     */
    Result set_rate_position_velocity_ned(double rate_hz) const;


    /**
     * @brief Set rate to 'ground truth' updates.
     */
    void set_rate_ground_truth_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_ground_truth_async().
     *
     * @return Result of request.
     */
    Result set_rate_ground_truth(double rate_hz) const;


    /**
     * @brief Set rate to 'fixedwing metrics' updates.
     */
    void set_rate_fixedwing_metrics_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_fixedwing_metrics_async().
     *
     * @return Result of request.
     */
    Result set_rate_fixedwing_metrics(double rate_hz) const;


    /**
     * @brief Set rate to 'IMU' updates.
     */
    void set_rate_imu_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_imu_async().
     *
     * @return Result of request.
     */
    Result set_rate_imu(double rate_hz) const;


    /**
     * @brief Set rate to 'unix epoch time' updates.
     */
    void set_rate_unix_epoch_time_async(double rate_hz, const result_callback_t callback);

    /**
     * @brief Synchronous wrapper for set_rate_unix_epoch_time_async().
     *
     * @return Result of request.
     */
    Result set_rate_unix_epoch_time(double rate_hz) const;




    /**
     * @brief Returns a human-readable English string for a Result.
     *
     * @param result The enum value for which a human readable string is required.
     * @return Human readable string for the Result.
     */
    static const char* result_str(Result result);


    /**
     * @brief Copy constructor (object is not copyable).
     */
    Telemetry(const Telemetry&) = delete;

    /**
     * @brief Equality operator (object is not copyable).
     */
    const Telemetry& operator=(const Telemetry&) = delete;

private:
    /** @private Underlying implementation, set at instantiation */
    std::unique_ptr<TelemetryImpl> _impl;
};

} // namespace mavsdk

#include "telemetry_operators.h"