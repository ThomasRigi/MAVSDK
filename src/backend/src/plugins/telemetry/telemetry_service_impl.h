// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/master/protos/telemetry/telemetry.proto)

#include "telemetry/telemetry.grpc.pb.h"
#include "plugins/telemetry/telemetry.h"

#include "log.h"

namespace mavsdk {
namespace backend {

template<typename Telemetry = Telemetry>
class TelemetryServiceImpl final : public rpc::telemetry::TelemetryService::Service {
public:
    TelemetryServiceImpl(Telemetry& telemetry) : _telemetry(telemetry) {}


    template<typename ResponseType>
    void fillResponseWithResult(ResponseType* response, mavsdk::Telemetry::Result& result) const
    {
        auto rpc_result = translateToRpcResult(result);

        auto* rpc_telemetry_result = new rpc::telemetry::TelemetryResult();
        rpc_telemetry_result->set_result(rpc_result);
        rpc_telemetry_result->set_result_str(mavsdk::Telemetry::result_str(result));

        response->set_allocated_action_result(rpc_telemetry_result);
    }


    static rpc::telemetry::FixType translateToRpcFixType(const mavsdk::Telemetry::FixType& fixType)
    {
        switch (fixType) {
            case mavsdk::Telemetry::FixType::NoGps:
                return rpc::telemetry::FixType_NO_GPS;
            case mavsdk::Telemetry::FixType::NoFix:
                return rpc::telemetry::FixType_NO_FIX;
            case mavsdk::Telemetry::FixType::Fix2D:
                return rpc::telemetry::FixType_FIX_2D;
            case mavsdk::Telemetry::FixType::Fix3D:
                return rpc::telemetry::FixType_FIX_3D;
            case mavsdk::Telemetry::FixType::FixDgps:
                return rpc::telemetry::FixType_FIX_DGPS;
            case mavsdk::Telemetry::FixType::RtkFloat:
                return rpc::telemetry::FixType_RTK_FLOAT;
            case mavsdk::Telemetry::FixType::RtkFixed:
                return rpc::telemetry::FixType_RTK_FIXED;
            default:
                return rpc::telemetry::FixType_UNKNOWN;
        }
    }

    /*
    static mavsdk::Telemetry::FixType translateFromRpcFixType(const rpc::telemetry::FixType& fixType)
    {
        switch (fixType) {
            case rpc::telemetry::FixType_NO_GPS:
                return mavsdk::Telemetry::FixType::NoGps;
            case rpc::telemetry::FixType_NO_FIX:
                return mavsdk::Telemetry::FixType::NoFix;
            case rpc::telemetry::FixType_FIX_2D:
                return mavsdk::Telemetry::FixType::Fix2D;
            case rpc::telemetry::FixType_FIX_3D:
                return mavsdk::Telemetry::FixType::Fix3D;
            case rpc::telemetry::FixType_FIX_DGPS:
                return mavsdk::Telemetry::FixType::FixDgps;
            case rpc::telemetry::FixType_RTK_FLOAT:
                return mavsdk::Telemetry::FixType::RtkFloat;
            case rpc::telemetry::FixType_RTK_FIXED:
                return mavsdk::Telemetry::FixType::RtkFixed;
            default:
                return mavsdk::Telemetry::FixType::Unknown;
        }
    }
    */

    static rpc::telemetry::FlightMode translateToRpcFlightMode(const mavsdk::Telemetry::FlightMode& flightMode)
    {
        switch (flightMode) {
            case mavsdk::Telemetry::FlightMode::Unknown:
                return rpc::telemetry::FlightMode_UNKNOWN;
            case mavsdk::Telemetry::FlightMode::Ready:
                return rpc::telemetry::FlightMode_READY;
            case mavsdk::Telemetry::FlightMode::Takeoff:
                return rpc::telemetry::FlightMode_TAKEOFF;
            case mavsdk::Telemetry::FlightMode::Hold:
                return rpc::telemetry::FlightMode_HOLD;
            case mavsdk::Telemetry::FlightMode::Mission:
                return rpc::telemetry::FlightMode_MISSION;
            case mavsdk::Telemetry::FlightMode::ReturnToLaunch:
                return rpc::telemetry::FlightMode_RETURN_TO_LAUNCH;
            case mavsdk::Telemetry::FlightMode::Land:
                return rpc::telemetry::FlightMode_LAND;
            case mavsdk::Telemetry::FlightMode::Offboard:
                return rpc::telemetry::FlightMode_OFFBOARD;
            case mavsdk::Telemetry::FlightMode::FollowMe:
                return rpc::telemetry::FlightMode_FOLLOW_ME;
            case mavsdk::Telemetry::FlightMode::Manual:
                return rpc::telemetry::FlightMode_MANUAL;
            case mavsdk::Telemetry::FlightMode::Altctl:
                return rpc::telemetry::FlightMode_ALTCTL;
            case mavsdk::Telemetry::FlightMode::Posctl:
                return rpc::telemetry::FlightMode_POSCTL;
            case mavsdk::Telemetry::FlightMode::Acro:
                return rpc::telemetry::FlightMode_ACRO;
            case mavsdk::Telemetry::FlightMode::Stabilized:
                return rpc::telemetry::FlightMode_STABILIZED;
            case mavsdk::Telemetry::FlightMode::Rattitude:
                return rpc::telemetry::FlightMode_RATTITUDE;
            default:
                return rpc::telemetry::FlightMode_UNKNOWN;
        }
    }

    /*
    static mavsdk::Telemetry::FlightMode translateFromRpcFlightMode(const rpc::telemetry::FlightMode& flightMode)
    {
        switch (flightMode) {
            case rpc::telemetry::FlightMode_UNKNOWN:
                return mavsdk::Telemetry::FlightMode::Unknown;
            case rpc::telemetry::FlightMode_READY:
                return mavsdk::Telemetry::FlightMode::Ready;
            case rpc::telemetry::FlightMode_TAKEOFF:
                return mavsdk::Telemetry::FlightMode::Takeoff;
            case rpc::telemetry::FlightMode_HOLD:
                return mavsdk::Telemetry::FlightMode::Hold;
            case rpc::telemetry::FlightMode_MISSION:
                return mavsdk::Telemetry::FlightMode::Mission;
            case rpc::telemetry::FlightMode_RETURN_TO_LAUNCH:
                return mavsdk::Telemetry::FlightMode::ReturnToLaunch;
            case rpc::telemetry::FlightMode_LAND:
                return mavsdk::Telemetry::FlightMode::Land;
            case rpc::telemetry::FlightMode_OFFBOARD:
                return mavsdk::Telemetry::FlightMode::Offboard;
            case rpc::telemetry::FlightMode_FOLLOW_ME:
                return mavsdk::Telemetry::FlightMode::FollowMe;
            case rpc::telemetry::FlightMode_MANUAL:
                return mavsdk::Telemetry::FlightMode::Manual;
            case rpc::telemetry::FlightMode_ALTCTL:
                return mavsdk::Telemetry::FlightMode::Altctl;
            case rpc::telemetry::FlightMode_POSCTL:
                return mavsdk::Telemetry::FlightMode::Posctl;
            case rpc::telemetry::FlightMode_ACRO:
                return mavsdk::Telemetry::FlightMode::Acro;
            case rpc::telemetry::FlightMode_STABILIZED:
                return mavsdk::Telemetry::FlightMode::Stabilized;
            case rpc::telemetry::FlightMode_RATTITUDE:
                return mavsdk::Telemetry::FlightMode::Rattitude;
            default:
                return mavsdk::Telemetry::FlightMode::Unknown;
        }
    }
    */

    static rpc::telemetry::LandedState translateToRpcLandedState(const mavsdk::Telemetry::LandedState& landedState)
    {
        switch (landedState) {
            case mavsdk::Telemetry::LandedState::LandedStateUnknown:
                return rpc::telemetry::LandedState_LANDED_STATE_UNKNOWN;
            case mavsdk::Telemetry::LandedState::LandedStateOnGround:
                return rpc::telemetry::LandedState_LANDED_STATE_ON_GROUND;
            case mavsdk::Telemetry::LandedState::LandedStateInAir:
                return rpc::telemetry::LandedState_LANDED_STATE_IN_AIR;
            case mavsdk::Telemetry::LandedState::LandedStateTakingOff:
                return rpc::telemetry::LandedState_LANDED_STATE_TAKING_OFF;
            case mavsdk::Telemetry::LandedState::LandedStateLanding:
                return rpc::telemetry::LandedState_LANDED_STATE_LANDING;
            default:
                return rpc::telemetry::LandedState_UNKNOWN;
        }
    }

    /*
    static mavsdk::Telemetry::LandedState translateFromRpcLandedState(const rpc::telemetry::LandedState& landedState)
    {
        switch (landedState) {
            case rpc::telemetry::LandedState_LANDED_STATE_UNKNOWN:
                return mavsdk::Telemetry::LandedState::LandedStateUnknown;
            case rpc::telemetry::LandedState_LANDED_STATE_ON_GROUND:
                return mavsdk::Telemetry::LandedState::LandedStateOnGround;
            case rpc::telemetry::LandedState_LANDED_STATE_IN_AIR:
                return mavsdk::Telemetry::LandedState::LandedStateInAir;
            case rpc::telemetry::LandedState_LANDED_STATE_TAKING_OFF:
                return mavsdk::Telemetry::LandedState::LandedStateTakingOff;
            case rpc::telemetry::LandedState_LANDED_STATE_LANDING:
                return mavsdk::Telemetry::LandedState::LandedStateLanding;
            default:
                return mavsdk::Telemetry::LandedState::Unknown;
        }
    }
    */



    static std::unique_ptr<rpc::telemetry::Position> translatePosition(const mavsdk::Telemetry::Position &position)
    {
        auto rpc_position = std::unique_ptr<rpc::telemetry::Position>(new rpc::telemetry::Position());


        rpc_position->set_latitude_deg(position.latitude_deg);
        rpc_position->set_longitude_deg(position.longitude_deg);
        rpc_position->set_absolute_altitude_m(position.absolute_altitude_m);
        rpc_position->set_relative_altitude_m(position.relative_altitude_m);

        return rpc_position;
    }




    static std::unique_ptr<rpc::telemetry::Quaternion> translateQuaternion(const mavsdk::Telemetry::Quaternion &quaternion)
    {
        auto rpc_quaternion = std::unique_ptr<rpc::telemetry::Quaternion>(new rpc::telemetry::Quaternion());


        rpc_quaternion->set_w(quaternion.w);
        rpc_quaternion->set_x(quaternion.x);
        rpc_quaternion->set_y(quaternion.y);
        rpc_quaternion->set_z(quaternion.z);

        return rpc_quaternion;
    }




    static std::unique_ptr<rpc::telemetry::EulerAngle> translateEulerAngle(const mavsdk::Telemetry::EulerAngle &euler_angle)
    {
        auto rpc_euler_angle = std::unique_ptr<rpc::telemetry::EulerAngle>(new rpc::telemetry::EulerAngle());


        rpc_euler_angle->set_roll_deg(euler_angle.roll_deg);
        rpc_euler_angle->set_pitch_deg(euler_angle.pitch_deg);
        rpc_euler_angle->set_yaw_deg(euler_angle.yaw_deg);

        return rpc_euler_angle;
    }




    static std::unique_ptr<rpc::telemetry::AngularVelocityBody> translateAngularVelocityBody(const mavsdk::Telemetry::AngularVelocityBody &angular_velocity_body)
    {
        auto rpc_angular_velocity_body = std::unique_ptr<rpc::telemetry::AngularVelocityBody>(new rpc::telemetry::AngularVelocityBody());


        rpc_angular_velocity_body->set_roll_rad_s(angular_velocity_body.roll_rad_s);
        rpc_angular_velocity_body->set_pitch_rad_s(angular_velocity_body.pitch_rad_s);
        rpc_angular_velocity_body->set_yaw_rad_s(angular_velocity_body.yaw_rad_s);

        return rpc_angular_velocity_body;
    }




    static std::unique_ptr<rpc::telemetry::SpeedNed> translateSpeedNed(const mavsdk::Telemetry::SpeedNed &speed_ned)
    {
        auto rpc_speed_ned = std::unique_ptr<rpc::telemetry::SpeedNed>(new rpc::telemetry::SpeedNed());


        rpc_speed_ned->set_velocity_north_m_s(speed_ned.velocity_north_m_s);
        rpc_speed_ned->set_velocity_east_m_s(speed_ned.velocity_east_m_s);
        rpc_speed_ned->set_velocity_down_m_s(speed_ned.velocity_down_m_s);

        return rpc_speed_ned;
    }




    static std::unique_ptr<rpc::telemetry::GpsInfo> translateGpsInfo(const mavsdk::Telemetry::GpsInfo &gps_info)
    {
        auto rpc_gps_info = std::unique_ptr<rpc::telemetry::GpsInfo>(new rpc::telemetry::GpsInfo());


        rpc_gps_info->set_num_satellites(gps_info.num_satellites);
        rpc_gps_info->set_fix_type(gps_info.fix_type);

        return rpc_gps_info;
    }




    static std::unique_ptr<rpc::telemetry::Battery> translateBattery(const mavsdk::Telemetry::Battery &battery)
    {
        auto rpc_battery = std::unique_ptr<rpc::telemetry::Battery>(new rpc::telemetry::Battery());


        rpc_battery->set_voltage_v(battery.voltage_v);
        rpc_battery->set_remaining_percent(battery.remaining_percent);

        return rpc_battery;
    }




    static std::unique_ptr<rpc::telemetry::Health> translateHealth(const mavsdk::Telemetry::Health &health)
    {
        auto rpc_health = std::unique_ptr<rpc::telemetry::Health>(new rpc::telemetry::Health());


        rpc_health->set_is_gyrometer_calibration_ok(health.is_gyrometer_calibration_ok);
        rpc_health->set_is_accelerometer_calibration_ok(health.is_accelerometer_calibration_ok);
        rpc_health->set_is_magnetometer_calibration_ok(health.is_magnetometer_calibration_ok);
        rpc_health->set_is_level_calibration_ok(health.is_level_calibration_ok);
        rpc_health->set_is_local_position_ok(health.is_local_position_ok);
        rpc_health->set_is_global_position_ok(health.is_global_position_ok);
        rpc_health->set_is_home_position_ok(health.is_home_position_ok);

        return rpc_health;
    }




    static std::unique_ptr<rpc::telemetry::RcStatus> translateRcStatus(const mavsdk::Telemetry::RcStatus &rc_status)
    {
        auto rpc_rc_status = std::unique_ptr<rpc::telemetry::RcStatus>(new rpc::telemetry::RcStatus());


        rpc_rc_status->set_was_available_once(rc_status.was_available_once);
        rpc_rc_status->set_is_available(rc_status.is_available);
        rpc_rc_status->set_signal_strength_percent(rc_status.signal_strength_percent);

        return rpc_rc_status;
    }



    static rpc::telemetry::StatusText::StatusType translateToRpcStatusType(const mavsdk::Telemetry::StatusType& statusType)
    {
        switch (statusType) {
            case mavsdk::Telemetry::StatusType::Info:
                return rpc::telemetry::StatusText_StatusType_INFO;
            case mavsdk::Telemetry::StatusType::Warning:
                return rpc::telemetry::StatusText_StatusType_WARNING;
            case mavsdk::Telemetry::StatusType::Critical:
                return rpc::telemetry::StatusText_StatusType_CRITICAL;
            default:
                return rpc::telemetry::StatusText_StatusType_UNKNOWN;
        }
    }

    /*
    static mavsdk::Telemetry::StatusType translateFromRpcStatusType(const rpc::telemetry::StatusText::StatusType& statusType)
    {
        switch (statusType) {
            case rpc::telemetry::StatusText_StatusType_INFO:
                return mavsdk::Telemetry::StatusType::Info;
            case rpc::telemetry::StatusText_StatusType_WARNING:
                return mavsdk::Telemetry::StatusType::Warning;
            case rpc::telemetry::StatusText_StatusType_CRITICAL:
                return mavsdk::Telemetry::StatusType::Critical;
            default:
                return mavsdk::Telemetry::StatusType::Unknown;
        }
    }
    */


    static std::unique_ptr<rpc::telemetry::StatusText> translateStatusText(const mavsdk::Telemetry::StatusText &status_text)
    {
        auto rpc_status_text = std::unique_ptr<rpc::telemetry::StatusText>(new rpc::telemetry::StatusText());


        rpc_status_text->set_type(status_text.type);
        rpc_status_text->set_text(status_text.text);

        return rpc_status_text;
    }




    static std::unique_ptr<rpc::telemetry::ActuatorControlTarget> translateActuatorControlTarget(const mavsdk::Telemetry::ActuatorControlTarget &actuator_control_target)
    {
        auto rpc_actuator_control_target = std::unique_ptr<rpc::telemetry::ActuatorControlTarget>(new rpc::telemetry::ActuatorControlTarget());


        rpc_actuator_control_target->set_group(actuator_control_target.group);
        rpc_actuator_control_target->set_controls(actuator_control_target.controls);

        return rpc_actuator_control_target;
    }




    static std::unique_ptr<rpc::telemetry::ActuatorOutputStatus> translateActuatorOutputStatus(const mavsdk::Telemetry::ActuatorOutputStatus &actuator_output_status)
    {
        auto rpc_actuator_output_status = std::unique_ptr<rpc::telemetry::ActuatorOutputStatus>(new rpc::telemetry::ActuatorOutputStatus());


        rpc_actuator_output_status->set_active(actuator_output_status.active);
        rpc_actuator_output_status->set_actuator(actuator_output_status.actuator);

        return rpc_actuator_output_status;
    }




    static std::unique_ptr<rpc::telemetry::Covariance> translateCovariance(const mavsdk::Telemetry::Covariance &covariance)
    {
        auto rpc_covariance = std::unique_ptr<rpc::telemetry::Covariance>(new rpc::telemetry::Covariance());


        rpc_covariance->set_covariance_matrix(covariance.covariance_matrix);

        return rpc_covariance;
    }




    static std::unique_ptr<rpc::telemetry::VelocityBody> translateVelocityBody(const mavsdk::Telemetry::VelocityBody &velocity_body)
    {
        auto rpc_velocity_body = std::unique_ptr<rpc::telemetry::VelocityBody>(new rpc::telemetry::VelocityBody());


        rpc_velocity_body->set_x_m_s(velocity_body.x_m_s);
        rpc_velocity_body->set_y_m_s(velocity_body.y_m_s);
        rpc_velocity_body->set_z_m_s(velocity_body.z_m_s);

        return rpc_velocity_body;
    }




    static std::unique_ptr<rpc::telemetry::PositionBody> translatePositionBody(const mavsdk::Telemetry::PositionBody &position_body)
    {
        auto rpc_position_body = std::unique_ptr<rpc::telemetry::PositionBody>(new rpc::telemetry::PositionBody());


        rpc_position_body->set_x_m(position_body.x_m);
        rpc_position_body->set_y_m(position_body.y_m);
        rpc_position_body->set_z_m(position_body.z_m);

        return rpc_position_body;
    }



    static rpc::telemetry::Odometry::MavFrame translateToRpcMavFrame(const mavsdk::Telemetry::MavFrame& mavFrame)
    {
        switch (mavFrame) {
            case mavsdk::Telemetry::MavFrame::Undef:
                return rpc::telemetry::Odometry_MavFrame_UNDEF;
            case mavsdk::Telemetry::MavFrame::BodyNed:
                return rpc::telemetry::Odometry_MavFrame_BODY_NED;
            case mavsdk::Telemetry::MavFrame::VisionNed:
                return rpc::telemetry::Odometry_MavFrame_VISION_NED;
            case mavsdk::Telemetry::MavFrame::EstimNed:
                return rpc::telemetry::Odometry_MavFrame_ESTIM_NED;
            default:
                return rpc::telemetry::Odometry_MavFrame_UNKNOWN;
        }
    }

    /*
    static mavsdk::Telemetry::MavFrame translateFromRpcMavFrame(const rpc::telemetry::Odometry::MavFrame& mavFrame)
    {
        switch (mavFrame) {
            case rpc::telemetry::Odometry_MavFrame_UNDEF:
                return mavsdk::Telemetry::MavFrame::Undef;
            case rpc::telemetry::Odometry_MavFrame_BODY_NED:
                return mavsdk::Telemetry::MavFrame::BodyNed;
            case rpc::telemetry::Odometry_MavFrame_VISION_NED:
                return mavsdk::Telemetry::MavFrame::VisionNed;
            case rpc::telemetry::Odometry_MavFrame_ESTIM_NED:
                return mavsdk::Telemetry::MavFrame::EstimNed;
            default:
                return mavsdk::Telemetry::MavFrame::Unknown;
        }
    }
    */


    static std::unique_ptr<rpc::telemetry::Odometry> translateOdometry(const mavsdk::Telemetry::Odometry &odometry)
    {
        auto rpc_odometry = std::unique_ptr<rpc::telemetry::Odometry>(new rpc::telemetry::Odometry());


        rpc_odometry->set_time_usec(odometry.time_usec);
        rpc_odometry->set_frame_id(odometry.frame_id);
        rpc_odometry->set_child_frame_id(odometry.child_frame_id);
        rpc_odometry->set_position_body(odometry.position_body);
        rpc_odometry->set_q(odometry.q);
        rpc_odometry->set_velocity_body(odometry.velocity_body);
        rpc_odometry->set_angular_velocity_body(odometry.angular_velocity_body);
        rpc_odometry->set_pose_covariance(odometry.pose_covariance);
        rpc_odometry->set_velocity_covariance(odometry.velocity_covariance);

        return rpc_odometry;
    }




    static std::unique_ptr<rpc::telemetry::PositionNed> translatePositionNed(const mavsdk::Telemetry::PositionNed &position_ned)
    {
        auto rpc_position_ned = std::unique_ptr<rpc::telemetry::PositionNed>(new rpc::telemetry::PositionNed());


        rpc_position_ned->set_north_m(position_ned.north_m);
        rpc_position_ned->set_east_m(position_ned.east_m);
        rpc_position_ned->set_down_m(position_ned.down_m);

        return rpc_position_ned;
    }




    static std::unique_ptr<rpc::telemetry::VelocityNed> translateVelocityNed(const mavsdk::Telemetry::VelocityNed &velocity_ned)
    {
        auto rpc_velocity_ned = std::unique_ptr<rpc::telemetry::VelocityNed>(new rpc::telemetry::VelocityNed());


        rpc_velocity_ned->set_north_m_s(velocity_ned.north_m_s);
        rpc_velocity_ned->set_east_m_s(velocity_ned.east_m_s);
        rpc_velocity_ned->set_down_m_s(velocity_ned.down_m_s);

        return rpc_velocity_ned;
    }




    static std::unique_ptr<rpc::telemetry::PositionVelocityNed> translatePositionVelocityNed(const mavsdk::Telemetry::PositionVelocityNed &position_velocity_ned)
    {
        auto rpc_position_velocity_ned = std::unique_ptr<rpc::telemetry::PositionVelocityNed>(new rpc::telemetry::PositionVelocityNed());


        rpc_position_velocity_ned->set_position(position_velocity_ned.position);
        rpc_position_velocity_ned->set_velocity(position_velocity_ned.velocity);

        return rpc_position_velocity_ned;
    }




    static std::unique_ptr<rpc::telemetry::GroundTruth> translateGroundTruth(const mavsdk::Telemetry::GroundTruth &ground_truth)
    {
        auto rpc_ground_truth = std::unique_ptr<rpc::telemetry::GroundTruth>(new rpc::telemetry::GroundTruth());


        rpc_ground_truth->set_latitude_deg(ground_truth.latitude_deg);
        rpc_ground_truth->set_longitude_deg(ground_truth.longitude_deg);
        rpc_ground_truth->set_absolute_altitude_m(ground_truth.absolute_altitude_m);

        return rpc_ground_truth;
    }




    static std::unique_ptr<rpc::telemetry::FixedwingMetrics> translateFixedwingMetrics(const mavsdk::Telemetry::FixedwingMetrics &fixedwing_metrics)
    {
        auto rpc_fixedwing_metrics = std::unique_ptr<rpc::telemetry::FixedwingMetrics>(new rpc::telemetry::FixedwingMetrics());


        rpc_fixedwing_metrics->set_airspeed_m_s(fixedwing_metrics.airspeed_m_s);
        rpc_fixedwing_metrics->set_throttle_percentage(fixedwing_metrics.throttle_percentage);
        rpc_fixedwing_metrics->set_climb_rate_m_s(fixedwing_metrics.climb_rate_m_s);

        return rpc_fixedwing_metrics;
    }




    static std::unique_ptr<rpc::telemetry::AccelerationFrd> translateAccelerationFrd(const mavsdk::Telemetry::AccelerationFrd &acceleration_frd)
    {
        auto rpc_acceleration_frd = std::unique_ptr<rpc::telemetry::AccelerationFrd>(new rpc::telemetry::AccelerationFrd());


        rpc_acceleration_frd->set_forward_m_s2(acceleration_frd.forward_m_s2);
        rpc_acceleration_frd->set_right_m_s2(acceleration_frd.right_m_s2);
        rpc_acceleration_frd->set_down_m_s2(acceleration_frd.down_m_s2);

        return rpc_acceleration_frd;
    }




    static std::unique_ptr<rpc::telemetry::AngularVelocityFrd> translateAngularVelocityFrd(const mavsdk::Telemetry::AngularVelocityFrd &angular_velocity_frd)
    {
        auto rpc_angular_velocity_frd = std::unique_ptr<rpc::telemetry::AngularVelocityFrd>(new rpc::telemetry::AngularVelocityFrd());


        rpc_angular_velocity_frd->set_forward_rad_s(angular_velocity_frd.forward_rad_s);
        rpc_angular_velocity_frd->set_right_rad_s(angular_velocity_frd.right_rad_s);
        rpc_angular_velocity_frd->set_down_rad_s(angular_velocity_frd.down_rad_s);

        return rpc_angular_velocity_frd;
    }




    static std::unique_ptr<rpc::telemetry::MagneticFieldFrd> translateMagneticFieldFrd(const mavsdk::Telemetry::MagneticFieldFrd &magnetic_field_frd)
    {
        auto rpc_magnetic_field_frd = std::unique_ptr<rpc::telemetry::MagneticFieldFrd>(new rpc::telemetry::MagneticFieldFrd());


        rpc_magnetic_field_frd->set_forward_gauss(magnetic_field_frd.forward_gauss);
        rpc_magnetic_field_frd->set_right_gauss(magnetic_field_frd.right_gauss);
        rpc_magnetic_field_frd->set_down_gauss(magnetic_field_frd.down_gauss);

        return rpc_magnetic_field_frd;
    }




    static std::unique_ptr<rpc::telemetry::Imu> translateImu(const mavsdk::Telemetry::Imu &imu)
    {
        auto rpc_imu = std::unique_ptr<rpc::telemetry::Imu>(new rpc::telemetry::Imu());


        rpc_imu->set_acceleration_frd(imu.acceleration_frd);
        rpc_imu->set_angular_velocity_frd(imu.angular_velocity_frd);
        rpc_imu->set_magnetic_field_frd(imu.magnetic_field_frd);
        rpc_imu->set_temperature_degc(imu.temperature_degc);

        return rpc_imu;
    }



    static rpc::telemetry::TelemetryResult::Result translateToRpcResult(const mavsdk::Telemetry::Result& result)
    {
        switch (result) {
            case mavsdk::Telemetry::Result::Unknown:
                return rpc::telemetry::TelemetryResult_Result_UNKNOWN;
            case mavsdk::Telemetry::Result::Success:
                return rpc::telemetry::TelemetryResult_Result_SUCCESS;
            case mavsdk::Telemetry::Result::NoSystem:
                return rpc::telemetry::TelemetryResult_Result_NO_SYSTEM;
            case mavsdk::Telemetry::Result::ConnectionError:
                return rpc::telemetry::TelemetryResult_Result_CONNECTION_ERROR;
            case mavsdk::Telemetry::Result::Busy:
                return rpc::telemetry::TelemetryResult_Result_BUSY;
            case mavsdk::Telemetry::Result::CommandDenied:
                return rpc::telemetry::TelemetryResult_Result_COMMAND_DENIED;
            case mavsdk::Telemetry::Result::Timeout:
                return rpc::telemetry::TelemetryResult_Result_TIMEOUT;
            default:
                return rpc::telemetry::TelemetryResult_Result_UNKNOWN;
        }
    }

    /*
    static mavsdk::Telemetry::Result translateFromRpcResult(const rpc::telemetry::TelemetryResult::Result& result)
    {
        switch (result) {
            case rpc::telemetry::TelemetryResult_Result_UNKNOWN:
                return mavsdk::Telemetry::Result::Unknown;
            case rpc::telemetry::TelemetryResult_Result_SUCCESS:
                return mavsdk::Telemetry::Result::Success;
            case rpc::telemetry::TelemetryResult_Result_NO_SYSTEM:
                return mavsdk::Telemetry::Result::NoSystem;
            case rpc::telemetry::TelemetryResult_Result_CONNECTION_ERROR:
                return mavsdk::Telemetry::Result::ConnectionError;
            case rpc::telemetry::TelemetryResult_Result_BUSY:
                return mavsdk::Telemetry::Result::Busy;
            case rpc::telemetry::TelemetryResult_Result_COMMAND_DENIED:
                return mavsdk::Telemetry::Result::CommandDenied;
            case rpc::telemetry::TelemetryResult_Result_TIMEOUT:
                return mavsdk::Telemetry::Result::Timeout;
            default:
                return mavsdk::Telemetry::Result::Unknown;
        }
    }
    */




    grpc::Status Position(grpc::ServerContext * /* context */, const rpc::telemetry::PositionRequest *request, grpc::ServerWriter<rpc::telemetry::PositionResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.position_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::PositionResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status Home(grpc::ServerContext * /* context */, const rpc::telemetry::HomeRequest *request, grpc::ServerWriter<rpc::telemetry::HomeResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.home_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::HomeResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status InAir(grpc::ServerContext * /* context */, const rpc::telemetry::InAirRequest *request, grpc::ServerWriter<rpc::telemetry::InAirResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.in_air_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::InAirResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status LandedState(grpc::ServerContext * /* context */, const rpc::telemetry::LandedStateRequest *request, grpc::ServerWriter<rpc::telemetry::LandedStateResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.landed_state_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::LandedStateResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status Armed(grpc::ServerContext * /* context */, const rpc::telemetry::ArmedRequest *request, grpc::ServerWriter<rpc::telemetry::ArmedResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.armed_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::ArmedResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status AttitudeQuaternion(grpc::ServerContext * /* context */, const rpc::telemetry::AttitudeQuaternionRequest *request, grpc::ServerWriter<rpc::telemetry::AttitudeQuaternionResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.attitude_quaternion_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::AttitudeQuaternionResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status AttitudeEuler(grpc::ServerContext * /* context */, const rpc::telemetry::AttitudeEulerRequest *request, grpc::ServerWriter<rpc::telemetry::AttitudeEulerResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.attitude_euler_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::AttitudeEulerResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status AttitudeAngularVelocityBody(grpc::ServerContext * /* context */, const rpc::telemetry::AttitudeAngularVelocityBodyRequest *request, grpc::ServerWriter<rpc::telemetry::AttitudeAngularVelocityBodyResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.attitude_angular_velocity_body_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::AttitudeAngularVelocityBodyResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status CameraAttitudeQuaternion(grpc::ServerContext * /* context */, const rpc::telemetry::CameraAttitudeQuaternionRequest *request, grpc::ServerWriter<rpc::telemetry::CameraAttitudeQuaternionResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.camera_attitude_quaternion_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::CameraAttitudeQuaternionResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status CameraAttitudeEuler(grpc::ServerContext * /* context */, const rpc::telemetry::CameraAttitudeEulerRequest *request, grpc::ServerWriter<rpc::telemetry::CameraAttitudeEulerResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.camera_attitude_euler_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::CameraAttitudeEulerResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status GroundSpeedNed(grpc::ServerContext * /* context */, const rpc::telemetry::GroundSpeedNedRequest *request, grpc::ServerWriter<rpc::telemetry::GroundSpeedNedResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.ground_speed_ned_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::GroundSpeedNedResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status GpsInfo(grpc::ServerContext * /* context */, const rpc::telemetry::GpsInfoRequest *request, grpc::ServerWriter<rpc::telemetry::GpsInfoResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.gps_info_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::GpsInfoResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status Battery(grpc::ServerContext * /* context */, const rpc::telemetry::BatteryRequest *request, grpc::ServerWriter<rpc::telemetry::BatteryResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.battery_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::BatteryResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status FlightMode(grpc::ServerContext * /* context */, const rpc::telemetry::FlightModeRequest *request, grpc::ServerWriter<rpc::telemetry::FlightModeResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.flight_mode_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::FlightModeResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status Health(grpc::ServerContext * /* context */, const rpc::telemetry::HealthRequest *request, grpc::ServerWriter<rpc::telemetry::HealthResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.health_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::HealthResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status RcStatus(grpc::ServerContext * /* context */, const rpc::telemetry::RcStatusRequest *request, grpc::ServerWriter<rpc::telemetry::RcStatusResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.rc_status_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::RcStatusResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status StatusText(grpc::ServerContext * /* context */, const rpc::telemetry::StatusTextRequest *request, grpc::ServerWriter<rpc::telemetry::StatusTextResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.status_text_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::StatusTextResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status ActuatorControlTarget(grpc::ServerContext * /* context */, const rpc::telemetry::ActuatorControlTargetRequest *request, grpc::ServerWriter<rpc::telemetry::ActuatorControlTargetResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.actuator_control_target_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::ActuatorControlTargetResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status ActuatorOutputStatus(grpc::ServerContext * /* context */, const rpc::telemetry::ActuatorOutputStatusRequest *request, grpc::ServerWriter<rpc::telemetry::ActuatorOutputStatusResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.actuator_output_status_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::ActuatorOutputStatusResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status Odometry(grpc::ServerContext * /* context */, const rpc::telemetry::OdometryRequest *request, grpc::ServerWriter<rpc::telemetry::OdometryResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.odometry_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::OdometryResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status PositionVelocityNed(grpc::ServerContext * /* context */, const rpc::telemetry::PositionVelocityNedRequest *request, grpc::ServerWriter<rpc::telemetry::PositionVelocityNedResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.position_velocity_ned_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::PositionVelocityNedResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status GroundTruth(grpc::ServerContext * /* context */, const rpc::telemetry::GroundTruthRequest *request, grpc::ServerWriter<rpc::telemetry::GroundTruthResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.ground_truth_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::GroundTruthResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status FixedwingMetrics(grpc::ServerContext * /* context */, const rpc::telemetry::FixedwingMetricsRequest *request, grpc::ServerWriter<rpc::telemetry::FixedwingMetricsResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.fixedwing_metrics_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::FixedwingMetricsResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status Imu(grpc::ServerContext * /* context */, const rpc::telemetry::ImuRequest *request, grpc::ServerWriter<rpc::telemetry::ImuResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.imu_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::ImuResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status HealthAllOk(grpc::ServerContext * /* context */, const rpc::telemetry::HealthAllOkRequest *request, grpc::ServerWriter<rpc::telemetry::HealthAllOkResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.health_all_ok_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::HealthAllOkResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status UnixEpochTime(grpc::ServerContext * /* context */, const rpc::telemetry::UnixEpochTimeRequest *request, grpc::ServerWriter<rpc::telemetry::UnixEpochTimeResponse> *writer) override
    {
        std::promise<void> stream_closed_promise;
        auto stream_closed_future = stream_closed_promise.get_future();

        bool is_finished = false;

        _telemetry.unix_epoch_time_async([this, &writer, &stream_closed_promise, &is_finished](const mavsdk::Telemetry::Result result, const float progress, const std::string &status_text) {
            rpc::telemetry::UnixEpochTimeResponse rpc_response;
            rpc_response.set_allocated_telemetry_result(translateTelemetryResult(result).get());

            std::lock_guard<std::mutex> lock(_subscribe_mutex);
            if (!writer->Write(rpc_response) && !is_finished) {
                is_finished = true;
                stream_closed_promise.set_value();
            }
        });

        stream_closed_future.wait();
        return grpc::Status::OK;
    }

    grpc::Status SetRatePosition(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRatePositionRequest* request,
        rpc::telemetry::SetRatePositionResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRatePosition sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_position(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateHome(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateHomeRequest* request,
        rpc::telemetry::SetRateHomeResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateHome sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_home(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateInAir(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateInAirRequest* request,
        rpc::telemetry::SetRateInAirResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateInAir sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_in_air(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateLandedState(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateLandedStateRequest* request,
        rpc::telemetry::SetRateLandedStateResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateLandedState sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_landed_state(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateAttitude(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateAttitudeRequest* request,
        rpc::telemetry::SetRateAttitudeResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateAttitude sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_attitude(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateCameraAttitude(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateCameraAttitudeRequest* request,
        rpc::telemetry::SetRateCameraAttitudeResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateCameraAttitude sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_camera_attitude(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateGroundSpeedNed(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateGroundSpeedNedRequest* request,
        rpc::telemetry::SetRateGroundSpeedNedResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateGroundSpeedNed sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_ground_speed_ned(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateGpsInfo(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateGpsInfoRequest* request,
        rpc::telemetry::SetRateGpsInfoResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateGpsInfo sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_gps_info(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateBattery(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateBatteryRequest* request,
        rpc::telemetry::SetRateBatteryResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateBattery sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_battery(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateRcStatus(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateRcStatusRequest* request,
        rpc::telemetry::SetRateRcStatusResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateRcStatus sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_rc_status(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateActuatorControlTarget(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateActuatorControlTargetRequest* request,
        rpc::telemetry::SetRateActuatorControlTargetResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateActuatorControlTarget sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_actuator_control_target(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateActuatorOutputStatus(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateActuatorOutputStatusRequest* request,
        rpc::telemetry::SetRateActuatorOutputStatusResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateActuatorOutputStatus sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_actuator_output_status(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateOdometry(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateOdometryRequest* request,
        rpc::telemetry::SetRateOdometryResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateOdometry sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_odometry(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRatePositionVelocityNed(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRatePositionVelocityNedRequest* request,
        rpc::telemetry::SetRatePositionVelocityNedResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRatePositionVelocityNed sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_position_velocity_ned(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateGroundTruth(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateGroundTruthRequest* request,
        rpc::telemetry::SetRateGroundTruthResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateGroundTruth sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_ground_truth(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateFixedwingMetrics(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateFixedwingMetricsRequest* request,
        rpc::telemetry::SetRateFixedwingMetricsResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateFixedwingMetrics sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_fixedwing_metrics(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateImu(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateImuRequest* request,
        rpc::telemetry::SetRateImuResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateImu sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_imu(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

    grpc::Status SetRateUnixEpochTime(
        grpc::ServerContext* /* context */,
        const rpc::telemetry::SetRateUnixEpochTimeRequest* request,
        rpc::telemetry::SetRateUnixEpochTimeResponse* response) override
    {
        if (request == nullptr) {
            LogWarn() << "SetRateUnixEpochTime sent with a null request! Ignoring...";
            return grpc::Status::OK;
        }

        auto result = _telemetry.set_rate_unix_epoch_time(request->rate_hz());

        if (response != nullptr) {
            fillResponseWithResult(response, result);
        }

        return grpc::Status::OK;
    }

private:
    Telemetry &_telemetry;
};

} // namespace backend
} // namespace mavsdk